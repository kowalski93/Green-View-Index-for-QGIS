# -*- coding: utf-8 -*-

"""
/***************************************************************************
 GreenViewIndex
                                 A QGIS plugin
 A plugin for Green View Index (GVI) operations
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-04-21
        copyright            : (C) 2023 by Alexandros Voukenas
        email                : avoukenas@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Alexandros Voukenas'
__date__ = '2023-04-21'
__copyright__ = '(C) 2023 by Alexandros Voukenas'

# This will get replaced with a git SHA1 when you do a git archive

__revision__ = '$Format:%H$'
import os
import inspect
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtCore import QCoreApplication, QVariant
from qgis.core import (QgsProcessing,
                       QgsFeatureSink,
                       QgsVectorLayer,
                       QgsProcessingException,
                       QgsProcessingAlgorithm,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterFeatureSink,
                       QgsProcessingParameterField,
                       QgsProcessingParameterEnum,
                       QgsProcessingParameterNumber,
                       QgsProcessingParameterString,
                       QgsProcessingParameterBoolean,
                       QgsProcessingParameterFolderDestination,
                       QgsField,
                       QgsFields,
                       QgsFeature)
from qgis import processing
import requests,csv,os
from skimage.io import imread,imsave
from skimage.filters.rank import modal
import numpy as np

class CalculateGreenViewIndex(QgsProcessingAlgorithm):

    INPUT_POINTS = 'INPUT POINTS'
    
    INPUT_FIELD="ID FIELD"
    INPUT_FOLDER = 'INPUT FOLDER'
    INPUT_WRITE_MASKED='WRITE MASKED'
    
    OUTPUT = 'OUTPUT'

    def tr(self, string):
        """
        Returns a translatable string with the self.tr() function.
        """
        return QCoreApplication.translate('Processing', string)
    
    def icon(self):
        cmd_folder = os.path.split(inspect.getfile(inspect.currentframe()))[0]
        icon = QIcon(os.path.join(os.path.join(cmd_folder, 'calculate_logo.png')))
        return icon
        
    def createInstance(self):
        return CalculateGreenViewIndex()

    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm. This
        string should be fixed for the algorithm, and must not be localised.
        The name should be unique within each provider. Names should contain
        lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return 'calculate_green_view_index'

    def displayName(self):
        """
        Returns the translated algorithm name, which should be used for any
        user-visible display of the algorithm name.
        """
        return self.tr('Calculate Green View Index')

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string
        should be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to. This
        string should be fixed for the algorithm, and must not be localised.
        The group id should be unique within each provider. Group id should
        contain lowercase alphanumeric characters only and no spaces or other
        formatting characters.
        """
        return ''
        
    def shortHelpString(self):
        """
        Returns a localised short helper string for the algorithm. This string
        should provide a basic description about what the algorithm does and the
        parameters and outputs associated with it..
        """
        return self.tr("""Given an input sample points layer and a folder containing the Google Street View images for those points, this script calculates the Green View Index for each point.
                        The input folder is the same as the output folder from script 'Download Google Street View Images'. The Input sample points layer is the same as for that script as well.
                        The Unique ID field must also be set, in order to create correspondence between point feature and image file name.
                        The Write green mask images option is used to create output images that mask for non vegetation (vegetation pixel=255, everything else=0).""")

    def initAlgorithm(self, config=None):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """

        #add the input parameters to the algorithm
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT_POINTS,
                self.tr('Input sample points layer'),
                [QgsProcessing.TypeVectorPoint]
            )
        )
        self.addParameter(
        QgsProcessingParameterField(
                self.INPUT_FIELD,
                'Unique ID field from sample points layer',
                '',
                self.INPUT_POINTS)
        )

        self.addParameter(
            QgsProcessingParameterFolderDestination(
                self.INPUT_FOLDER,
                self.tr('Input Folder containging GSV images')
            )
        )
        
        self.addParameter(
            QgsProcessingParameterBoolean(
                self.INPUT_WRITE_MASKED,
                self.tr('Write green mask images')
            )
        )
        
        self.addParameter(
            QgsProcessingParameterFeatureSink(
                self.OUTPUT,
                self.tr('Output layer')
            )
        )

    def processAlgorithm(self, parameters, context, feedback):
        
        #define the parameters for the processing algorithm
        source = self.parameterAsSource(
            parameters,
            self.INPUT_POINTS,
            context
        )
        
        id_field=self.parameterAsString(
            parameters,
            self.INPUT_FIELD,
            context
        )
        
        img_folder=self.parameterAsString(
            parameters,
            self.INPUT_FOLDER,
            context
        )
        write_masked=self.parameterAsBoolean(
            parameters,
            self.INPUT_WRITE_MASKED,
            context
        )
        
        output_path=self.parameterAsString(
            parameters,
            self.OUTPUT,
            context
        )
        
        #set the fields for the output layer. It's one Double type field where the GVI value will be stored, and a unique ID field in order to join with the source layer.
        fields = QgsFields()
        fields.append(QgsField(id_field,QVariant.Double))
        fields.append(QgsField('GVI', QVariant.Double))
        
        (sink, dest_id) = self.parameterAsSink(
            parameters,
            self.OUTPUT,
            context, fields, 4, source.sourceCrs()
            )
        #A list to store point IDs and corresponding GVIs
        GVIS=[["pointID","GVI"]]
        #An initial value of zero, to help calculate GVIs
        d=0
        #Get all the image filenames from the specified directory
        filenames=os.listdir(img_folder)
        filename_init=filenames[0]
        all_imgs=len(filenames)
        #variable 'pointID_2' comes from the name of the image on the drive. For the first time, we use the first filename of the filename_init list
        pointID_2=filename_init.split("_")[1]
        
        #iterate through the filenames
        for i,filename in enumerate(filenames):
            if filename.endswith(".jpg") and "GVI" not in filename:
                #for that filename, get the pointID from its name
                pointID=filename.split("_")[1]
                fullpath=os.path.join(img_folder,filename)
                
                #read the image and split rgb bands
                img=imread(fullpath)
                
                r = img[:,:,0]
                g = img[:,:,1]
                b = img[:,:,2]
                
                #create an array of 255s with the same shape as input image. In the final image, pixels with value 255 will correspond to vegetation, while value 0 is anything else
                GVI_img=np.ones(b.shape,dtype=np.uint8)*255
                
                #convert b g r bands to uint16
                b=np.int16(b); g=np.int16(g); r=np.int16(r)
                
                #Extract green pixels according to Li et. al., 2015
                diff1=g-r
                diff2=g-b
                diff=diff1*diff2
                
                GVI_img[diff1<=0]=0
                GVI_img[diff2<=0]=0
                GVI_img[diff<50]=0
                GVI_img[(b+g+r)>520]=0 #an additional threshold to filter out too bright pixels
                
                GVI_img=modal(GVI_img,np.ones((11,11))) #an additional majority filter to smooth the result
                size=b.shape[0]*b.shape[1]
                
                GVIorig=round(len(GVI_img[GVI_img==255])/size,2)#calculate the GVI for that particular image
                
                if pointID==pointID_2: #if we are still on images of the same point, i.e, we didn't change pointID yet
                    d=d+GVIorig #sum the GVI values we have so far
                else: #if not, append that sum to the GVIs list, and reset the counter to 0
                    GVIS.append([int(pointID_2),d/6]) 
                    d=0
                    
                #read pointID_2 from the filename we are now. This will be used in the next iteration and the conditional on line 258
                pointID_2=filename.split("_")[1]
                
                #if user had checked to write green mask, it will be written on the directory
                if write_masked==True:
                    imsave(fullpath[0:-4]+"_GVI.jpg",GVI_img)
                    
            #some feedback on the percentage of images completed        
            pct=int((i+1)/all_imgs*100)
            if pct in [10,20,25,30,33,40,50,60,66,70,75,80,90,100]:
                feedback.pushInfo('Finished with {}% of images'.format(pct))
                
        #The GVI for the final point has to be appended outside of the iterator, because that case cannot be checked with the if else of line 258        
        GVIS.append([int(pointID_2),d/6])
        
        #write a csv file of the output. It will contain point IDs and corresponding GVI values
        csvfile=os.path.join(img_folder,"Points_GVIs.csv")
        
        with open(csvfile, 'w') as f:
            write = csv.writer(f)
            write.writerows(GVIS)
        csv_layer=QgsVectorLayer(csvfile,'gvis_csv')
        
        #an intermediate field calculator to be able to join with the initial layer
        points_str_field=processing.run("native:fieldcalculator", 
        {'INPUT':parameters[self.INPUT_POINTS],
        'FIELD_NAME':'id_str',
        'FIELD_TYPE':2,
        'FIELD_LENGTH':0, 
        'FIELD_PRECISION':0,
        'FORMULA':'\"{}\"'.format(parameters[self.INPUT_FIELD]),
        'OUTPUT':'TEMPORARY_OUTPUT',
        '--overwrite': True})['OUTPUT']
        
        #perform the join with the initial layer
        final_layer_joined=processing.run("native:joinattributestable", 
        {'INPUT':points_str_field,
        'FIELD':'id_str',
        'INPUT_2':csv_layer,
        'FIELD_2':'pointID',
        'FIELDS_TO_COPY':['GVI'],'METHOD':1,'DISCARD_NONMATCHING':False,'PREFIX':'',
        'OUTPUT':'TEMPORARY_OUTPUT',
        '--overwrite': True})['OUTPUT']
        
        #write that to feature Sink
        for i,f in enumerate(final_layer_joined.getFeatures()):
                new_feature =  QgsFeature()
                new_feature.setGeometry(f.geometry())
                new_feature.setAttributes([f[parameters[self.INPUT_FIELD]],f['GVI']])
                sink.addFeature(new_feature, QgsFeatureSink.FastInsert)

        return {self.OUTPUT: dest_id}